\chapter{Basic operations} 



\section{Data types} 

Each constant, variable, array or function in a programming language has an intrinsic data type associated. 
This type decides among other things the permitted values that the entity can have or the set of operations that can be performed with them.
For example, the set of integers in mathematics are represented in a programming language through \texttt{integer} data type. 
Then, a value $x\in \mathbb{Z}$ will be stored in an \texttt{integer} variable and operations like addition, multiplication or exponentiation are allowed. 

The data typing in a programming language could be explicit if the programmer needs to decide and declare the type for each variable or implicit when the language assumes the type. 
Furthermore, while some programming languages allow the use of some data types as if they were a different type (weak typing) others does not (strong typing). 
Python is mainly an implicit typing language since we can assign a value to a variable without declaring type, i.e. \texttt{a = 3} will automatically treat \texttt{a} as an integer. 
Fortran, on the contrary, is a explicit typing language because all variables must be previously declared with a specific type, i.e. \texttt{real :: x = 5.6}.

In the following examples the intrinsic data types in Fortran and Python are presented through some basic examples. 

Notice that Fortran provides five intrinsic data types but derived data types can be created either from intrinsic data types or from other derived types previously defined.
The five intrinsic types are of numeric nature: \texttt{integer}, \texttt{real} or \texttt{complex}, boolean nature: \texttt{logical} or text nature: \texttt{character}.

The numeric types of data behave like the mathematical abstractions of these sets while the boolean type gets the two possible values of the Boolean algebra; \texttt{True} and \texttt{False}. 
The \texttt{character} type can store strings with ASCII characters which includes alphanumeric, symbols and signs characters.   

The same data types are built-in in Python but with a different name (\texttt{int}, \texttt{float}, \texttt{complex}, \texttt{bool} and \texttt{str}). 
In addition, more data types can be found by default; of sequence nature: \texttt{list}, \texttt{tuple} or \texttt{range}, mapping nature: \texttt{dict} or set nature: \texttt{set} among others. 

These new types are used to store collections of data that can be at the same time any type of data. For example a list can contain strings together with integers and reals. 
A \texttt{list} is characterised by being ordered; the position within the list is kept, changeable; change, add, and remove items are allowed when needed in the execution of the code and allow duplicates; items can appear more than one time in the list, the difference between both elements comes with the index within the list. 
A \texttt{tuple} is quite the same than a \texttt{list}: ordered data collection that allows duplicates, however, these are unchangeable which means that once created we cannot change, add or remove items. 
Python allocates the required memory once and not reallocates it so this becomes a more memory efficient strategy.

A \texttt{set} in Python is also a collection of any type of data but in this case unordered and not allowing duplicate values. 
Notice that an element within the set, since it is not stored in a defined order (with an integer index pointing to them), two equal elements could not be distinguished.
In a set the data can be modified through built-in methods so for example mathematical set operations like union, intersection or difference can be performed.
The \texttt{frozenset} is similar but once created its content can not be modified. 
%Finally, a dictionary 



Fortran

\begin{verbatim}
    program data_types
    
    implicit none
    
    character (len=10,kind=1) :: string = 'data types'
    integer :: int = 1
    real :: x = 1.8
    complex :: com = (1,1)
    logical :: bool = .true.
    
    end program
\end{verbatim}







Python

\begin{verbatim}
    def data_type(): 
    
    string = "data types"
    integer = 1 
    real = 1.8 
    complex = 1 + 1j
    bool = True
    
    sets = "unordered set with distinct elements" 
    S = {string, integer, real, complex} 
    
    # print order is unpredictable 
    print("\n type=", type(S)) 
    for s in S: 
    print(" element =", s)
    
    lists = "ordered set allowing equal elements" 
    S = ["one", 5, 3.5, 5] 
    
    # lists are ordered  
    S[3] = 8
    print("\n type=", type(S))   
    for i in range(len(S)): 
    print(" element =", S[i]) 
    
    
    tuples ="inmutable ordered set" 
    S = ("one", 5, 3.5, 5)  
    
    # tuples are inmutable 
    print("\n type=", type(S))
    for i in range(len(S)): 
    print(" element =", S[i])   
    print("\n")   
    
    dictionaries = "ordered data values in key:value pairs"
    # mutable and do not allow duplicates"
    arrays = {"set":sets, "list":lists, "tuple":tuples, "dictionary":dictionaries} 
    
    for e in arrays:  
    print("{:12} {} {}".format(e, ":", arrays[e]) )
    print("\n")
\end{verbatim}







Georg Cantorgave the following definition: 

A set is a gathering together into a whole of definite, distinct objects of our perception or our thoughtâ€”which are called elements of the 
set.

Roster or enumeration notation defines a set by listing
its elements between curly brackets, separated by commas:
$$
A = \{ 4, 2, 1, 3 \}
$$
$$
B = \{ blue, white, red \}.
$$
In a set, all that matters is whether each element is in it or not, 
so the ordering of the elements in roster notation is irrelevant 
(in contrast, in a sequence, a tuple, or a permutation of a set, 
the ordering of the terms matters).

 
For example, {2, 4, 6} and {4, 6, 4, 2} represent the same set.

For sets with many elements, especially those following an implicit pattern,
the list of members can be abbreviated using an ellipsis '...'.
For instance, the set of the first thousand positive integers 
may be specified in roster notation as
$$
\{ 1, 2, 3, ..., 1000 \}.
$$



\newpage 
\subsection*{Fortran code}


\newpage 
\subsection*{Python code}
The same function is presented below coded with Python. Essentially both codes are quite similar, 
however, now data types for variables are not explicitly declared because 
Python automatically declares them. In addition, indentation rules must be strictly followed. 
\vspace{0.5cm} 
\lstpython
\renewcommand{\home}{./Python/sources/Foundations/data_type} 
\listingsp{\home/data_type.py}{def}{format}{data_type.py}
%\lstfor
  

Explain  3 iterators with for Python: 

for v in V: 
for i in range(len(V)): 
for i, v in enumerate(V):

\newpage 
\section{Roots of a second degree equation} 
In this section, a program to obtain the roots of a second order equation is presented:  
$$
a x^2 + b x + c = 0, \qquad \forall \ a, b, c \in \mathbb{R}.
$$
The fundamental theorem of algebra states that every  Nth order polynomial has N complex roots. 
If the coefficients are real, then the roots are complex conjugate.
Dividing the above equation by $ a $ an looking for a perfect square, 
the following equation is obtained: 
$$
\left( x + \frac{b}{2a} \right)^2 - \frac{b^2 }{ 4 a^2} + \frac{c}{a} = 0. 
$$
Solving the unknown $x$, the well known formula for the roots is obtained: 
\begin{equation}
 x_{1,2} = \frac{ - b \pm \sqrt{ b^2 - 4 a c }  }{ 2 a  }  
 \label{x12}
\end{equation} 
If the discriminant $ d = b^2 - 4 a c $ is less than zero, roots become complex. 
In the following code, complex solutions given by (\ref{x12}) are implemented. 
Note that the discriminant $ d $ was defined as a complex variable to avoid math problems 
when the discriminant is negative. Whereas the root of a real negative number is not defined,
the root of a negative number has a value for complex numbers. 
 
\vspace{0.5cm}
\lstfor
\listings{\home/Roots.f90}{subroutine Roots_2th}{end subroutine}{Roots.f90}


\newpage 
\subsection*{Python code}
The same function is presented below coded with Python. Essentially both codes are quite similar, 
however, now data types for variables are not explicitly declared because 
Python automatically declares them. In addition, indentation rules must be strictly followed. 
\vspace{0.5cm} 
\lstpython
\renewcommand{\home}{./Python/sources/Foundations/Roots} 
\listingsp{\home/Roots.py}{from}{output}{Roots.py}
%\lstfor
  
  
 