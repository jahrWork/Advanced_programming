\chapter{Operations and von Neumann style} 

\renewcommand{\home}{./Fortran/sources/Foundations/Roots}



\section{Introduction}
Let's revise some pillars of the computation through the names of the people that developed them; Turing, Church, Neumann and Backus. 
Some notions of theory of computation are revised here so a reader that is new to the scientific programming can familiarize himself. 

The theory of computation gives us the basis for the automatic processing of information where we have a \textbf{problem} to solve (a relation or function between a bunch of inputs and their associated outputs) and we want a machine (analog, digital, quantum, etc.) to solve it. 
The tools of theory of computation will tell us if our problem can be solved in the framework of a \textbf{model of computation}, using an \textbf{algorithm} and how \textbf{efficiently} is going to be solved. 
An essential concept arise here, the model of computation is a mathematical abstract construction that describes how to compute the output of a mathematical function given its input. 

%Turing Universal machine
This leads us to the concept of Turing machine, the model of computation invented by Alan Turing to give answer to some essential questions in the theory of computation and mathematics in general. This abstract construction consists on a scanning head capable of reading from an infinite tape of cells a single cell at a time. This tape has information coded and once a cell is read, the machine can delete that cell, write another symbol or leave the symbol. Then, it can move to a different position in the tape. According to the current state of the machine and the position in the tape the machine follow a set of rules (also coded) and take some action or another. 

Everything that is computable and everything that a machine can compute nowadays can be theoretically programmed in a Touring machine although maybe inefficiently. Furthermore, it is said that any system capable of doing what a Touring machine can do is Touring-complete and than can also compute everything that is computable. Applying this idea to programming languages and real machines we can find if any computable algorithm can be performed in it and it turns that all programming languages nowadays are Touring-complete as soon as they allow mainly if-then-else structures and go-to statements. 

We see then that a conceptual model of computation is intimately related to the programming languages (the software codes we create) and the real machines we use everyday from a hardware point of view (laptops, PCs, smartphones, etc.). Computers today are built by implementing what a Turing machine describes theoretically, using an architecture. The architecture is the set of rules and methods that describe how software and hardware in a machine are organized, interrelate and work to conform a computer.

%von Neumann architecture
Let's briefly describe what a von Neumann architecture is, mainly used in the machine around us. In this description of a computer, a Central Processing Unit (CPU) is in charge of executing the instructions that are stored in a Memory Unit separated from the CPU. In that memory, data and program are stored together and each memory position is uniquely identified by an address. Some Buses transfer information between different parts of the computer; data, addresses or control commands. Finally, input/output devices can communicate with the machine using the Buses too. Notice firstly that this is not the only possible architecture for a machine. Secondly, this architecture describes not only how the hardware is organized but also how data and programs work so programming languages are also influenced by this architecture. 


%RAM model and Church lambda 
Different computation models exist apart from the Turing machine, Random-access Machines (RAM) or lambda calculus ($\lambda$-calculus) are some of them. Some of these computation models give rise to a programming paradigm like imperative programming or functional programming. The former finds its foundations in the Touring machine and the latter is supported by the concepts of lambda calculus, developed by Alonzo Church. All computable algorithms can be computed using lambda calculus so it is Turing complete and is built with three kind of terms: variables, abstractions and applications. This model is focused on the use of transformation rules and not in the machine that implements these rules so it is closer to software than hardware. Essentially an abstraction here can be seen as a function (with an argument and a function body) so the programs are built by applying functions to other functions instead of assigning (storing) values to variables and iterate  process. 


%Paradigmas, instructions, machine and style
%Backus Fortran and its paper 
This strong relation between imperative programming languages and the von Neumann computer was treated by John Backus in its paper ``Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs''. He remarks the parallelism between the von Neumann memory and the use of variables to store data or the instruction cycle of a CPU (fetch, store, execute) with the assignment statement of a programming language. Furthermore, this assignment statement splits the programming languages into two worlds: a world of expressions with strong algebraic properties and a world of statements with few mathematical properties. In this paper, he proposes an alternative to this reality based on the functional programming style. 

Imperative and declarative programming paradigms are treated in the following section using examples that illustrate the main difference between them: when a programmer tells the machine how to perform each task step by step or when the programmer just tells what to obtain and its properties but not the control flow to perform the task. 

%Example of code 3*2 



\newpage 
\section{Roots of a second degree equation} 
In this section, a program to obtain the roots of a second order equation is presented:  
$$
a x^2 + b x + c = 0, \qquad \forall \ a, b, c \in \mathbb{R}.
$$
The fundamental theorem of algebra states that every  Nth order polynomial has N complex roots. 
If the coefficients are real, then the roots are complex conjugate.
Dividing the above equation by $ a $ an looking for a perfect square, 
the following equation is obtained: 
$$
\left( x + \frac{b}{2a} \right)^2 - \frac{b^2 }{ 4 a^2} + \frac{c}{a} = 0. 
$$
Solving the unknown $x$, the well known formula for the roots is obtained: 
\begin{equation}
 x_{1,2} = \frac{ - b \pm \sqrt{ b^2 - 4 a c }  }{ 2 a  }  
 \label{x12}
\end{equation} 
If the discriminant $ d = b^2 - 4 a c $ is less than zero, roots become complex. 
In the following code, complex solutions given by (\ref{x12}) are implemented. 
Note that the discriminant $ d $ was defined as a complex variable to avoid math problems 
when the discriminant is negative. Whereas the root of a real negative number is not defined,
the root of a negative number has a value for complex numbers. 
 
\vspace{0.5cm}
\listings{\home/Roots.f90}{subroutine Roots_2th}{end subroutine}{Roots.f90}



\newpage 
\subsection*{Python code}
The same function is presented below coded with Python. Essentially both codes are quite similar, 
however, now data types for variables are not explicitly declared because 
Python automatically declares them. In addition, indentation rules must be strictly followed. 
\vspace{0.5cm} 
\lstpython
\renewcommand{\home}{./Python/sources/Foundations/Roots} 
\listings{\home/Roots.py}{from}{output}{Roots.py}
\lstfor
  
  
  
  
